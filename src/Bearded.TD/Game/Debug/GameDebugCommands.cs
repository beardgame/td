using System;
using System.Collections.Generic;
using Bearded.TD.Game.Generation;
using Bearded.TD.Game.Simulation.Buildings;
using Bearded.TD.Game.Simulation.Buildings.Veterancy;
using Bearded.TD.Game.Simulation.Damage;
using Bearded.TD.Game.Simulation.Exploration;
using Bearded.TD.Game.Simulation.Factions;
using Bearded.TD.Game.Simulation.GameLoop;
using Bearded.TD.Game.Simulation.Resources;
using Bearded.TD.Game.Simulation.Technologies;
using Bearded.TD.Game.Simulation.Units;
using Bearded.TD.Utilities;
using Bearded.TD.Utilities.Console;
using Bearded.Utilities;
using Bearded.Utilities.IO;

namespace Bearded.TD.Game.Debug;

static class GameDebugCommands
{
    [Command("game.seed")]
    private static void seed(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        logger.Info?.Log(gameInstance.GameSettings.Seed);
    });

    [CommandParameterCompletion("terrain.generators")]
    private static IEnumerable<string> getTerrainGenerators() => Enum.GetNames<LevelGenerationMethod>();

    [DebugCommand("game.generateterrain", "terrain.generators")]
    private static void generateTerrain(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length == 0)
        {
            logger.Warning?.Log("Usage: \"game.generateterrain <method> [seed|'random']\"");
            return;
        }

        if (!Enum.TryParse<LevelGenerationMethod>(p.Args[0], true, out var method))
        {
            logger.Warning?.Log("Valid methods are:");
            foreach (var name in Enum.GetNames<LevelGenerationMethod>())
            {
                logger.Warning?.Log(name);
            }
            return;
        }

        var seed = p.Args.Length == 1
            ? gameInstance.GameSettings.Seed
            : int.TryParse(p.Args[1], out var s) ? s : StaticRandom.Int();

        // TODO: seeds are broken, see GameStateBuilder too
        if (seed == 0)
            seed = StaticRandom.Int();

        logger.Debug?.Log($"Generating new tilemap with method {method} and seed {seed}.");

        gameInstance.LevelDebugMetadata.Clear();
        gameInstance.State.ZoneLayer.ResetZones();

        // TODO: this is a bit of a hacky solution. The better way would be to regenerate the entire game state.
        //       However, that would benefit from having game state/game instance refactored, so that this leads to
        //       less pollution of objects escaping their respective abstraction layer.
        foreach (var gameObj in gameInstance.State.GameObjects)
        {
            gameObj.Delete();
        }

        var generator = TilemapGenerator.From(method, logger, gameInstance.LevelDebugMetadata);

        var levelGenerationParameters = LevelGenerationParametersFactory.Create(gameInstance);
        var commandFactories = generator.Generate(levelGenerationParameters, seed);

        // TODO: clean up things generated by level generation commands?
        foreach (var commandFactory in commandFactories)
        {
            gameInstance.Meta.Dispatcher.RunOnlyOnServer(() => commandFactory(gameInstance));
        }
        // TODO: do other work done in GameStateBuilder to create valid playable level?
    });

    [DebugCommand("game.die")]
    private static void die(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, DebugGameOver.Request(gameInstance.State));
    });

    [DebugCommand("game.building.xp")]
    private static void buildingXp(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length != 1)
        {
            logger.Warning?.Log("Usage: \"game.building.xp <amount>\"");
            return;
        }

        if (!float.TryParse(p.Args[0], out var amount))
        {
            logger.Warning?.Log($"Invalid amount: {p.Args[0]}");
            return;
        }

        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, GiveBuildingXp.Request(gameInstance, amount.Xp()));
    });

    [DebugCommand("game.building.level")]
    private static void buildingLevel(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, GiveBuildingLevel.Request(gameInstance));
    });

    [DebugCommand("game.building.stun")]
    private static void buildingStun(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length > 1)
        {
            logger.Warning?.Log("Usage: \"game.building.stun [duration]\"");
            return;
        }

        var durationS = 2.0;
        if (p.Args.Length == 1 && !double.TryParse(p.Args[0], out durationS))
        {
            logger.Warning?.Log($"Invalid duration: {p.Args[0]}");
            return;
        }

        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, StunAllBuildings.Request(gameInstance, durationS.S()));
    });

    [DebugCommand("game.killall")]
    private static void killAll(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        gameInstance.RequestDispatcher.Dispatch(
            gameInstance.Me, KillAllEnemies.Request(gameInstance, DivineIntervention.DamageSource));
    });

    [DebugCommand("game.repairall")]
    private static void repairAll(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, RepairAllBuildings.Request(gameInstance));
    });

    [DebugCommand("game.revealmap")]
    private static void revealMap(Logger logger, CommandParameters _) => run(logger, gameInstance =>
    {
        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, RevealMap.Request(gameInstance));
    });

    [DebugCommand("game.resources")]
    private static void giveResources(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length != 1)
        {
            logger.Warning?.Log("Usage: \"game.resources <amount>\"");
            return;
        }

        if (!int.TryParse(p.Args[0], out var amount))
        {
            logger.Warning?.Log($"Invalid amount: {amount}");
            return;
        }

        var faction = gameInstance.Me.Faction;
        while (faction != null && !faction.TryGetBehavior<FactionResources>(out _))
        {
            faction = faction.Parent;
        }

        if (faction == null)
        {
            logger.Warning?.Log($"Cannot add resources: player is not part of a faction with resource management.");
            return;
        }

        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, GrantResources.Request(faction, amount.Scrap()));
    });

    [DebugCommand("game.techtoken")]
    private static void giveTechToken(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length != 0)
        {
            logger.Warning?.Log("Usage: \"game.techtoken\"");
            return;
        }

        if (findTechFaction(gameInstance) is not { } faction)
        {
            logger.Warning?.Log(
                "Cannot add tech points: player is not part of a faction with technology management.");
            return;
        }

        gameInstance.RequestDispatcher.Dispatch(gameInstance.Me, GrantTechToken.Request(faction));
    });

    [DebugCommand("game.alltech")]
    private static void unlockAllTech(Logger logger, CommandParameters p) => run(logger, gameInstance =>
    {
        if (p.Args.Length != 0)
        {
            logger.Warning?.Log("Usage: \"game.alltech\"");
            return;
        }

        if (findTechFaction(gameInstance) is not { } faction)
        {
            logger.Warning?.Log(
                "Cannot unlock tech: player is not part of a faction with technology management.");
            return;
        }

        gameInstance.RequestDispatcher.Dispatch(
            gameInstance.Me, ForceUnlockAllTechnologies.Request(gameInstance, faction));
    });

    private static Faction? findTechFaction(GameInstance gameInstance)
    {
        Faction? faction = gameInstance.Me.Faction;
        while (faction != null && !faction.TryGetBehavior<FactionTechnology>(out _))
        {
            faction = faction.Parent;
        }

        return faction;
    }

    private static void run(Logger logger, Action<GameInstance> command) =>
        DebugGameManager.Instance.RunCommandOrLog(logger, command);
}
