using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Bearded.TD.Generators.DiagnosticFactory;

namespace Bearded.TD.Generators.Dependencies;

[Generator]
sealed class DependencyGenerator : IIncrementalGenerator
{
    private const string fullAttributeName = "Bearded.TD.Game.Simulation.GameObjects.InjectAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
        Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;

        var fieldsToGenerateFor = SyntaxProviders
            .FieldsWithAttribute(context.SyntaxProvider, fullAttributeName);

        var fieldsWithCompilation = context.CompilationProvider.Combine(fieldsToGenerateFor.Collect());

        context.RegisterSourceOutput(
            fieldsWithCompilation, (spc, source) => execute(source.Left, source.Right, spc));
    }


    private static void execute(
        Compilation compilation,
        ImmutableArray<FieldDeclarationSyntax> fieldsToGenerateFor,
        SourceProductionContext context)
    {
        try
        {
            // var injectAttribute = compilation.GetTypeByMetadataName(fullAttributeName) ??
            //     throw new InvalidOperationException("Could not find inject attribute");

            var fieldsByClass = fieldsToGenerateFor
                .Select(compilation.ResolveFieldSymbol)
                .ToLookup(symbol => symbol.ContainingSymbol, SymbolEqualityComparer.Default);

            foreach (var grouping in fieldsByClass)
            {
                var classSymbol = grouping.Key as INamedTypeSymbol ?? throw new InvalidOperationException();
                var fieldSymbols = grouping.ToImmutableArray();
                var source = SourceText.From(
                    generateClass($"{classSymbol.ContainingNamespace}", classSymbol.Name, fieldSymbols),
                    Encoding.Default);
                context.AddSource(classSymbol.Name, source);
            }
        }
        catch (Exception e)
        {
            context.ReportDiagnostic(CreateDebugDiagnostic(e.ToString(), DiagnosticSeverity.Error));
        }
    }

    private static string generateClass(string ns, string className, IEnumerable<IFieldSymbol> fields)
    {
        return $@"// This file is generated by Bearded.TD.Generators

using System;

namespace {ns};

partial class {className}
{{{generateMethod(fields)}
}}
";
    }

    private static string generateMethod(IEnumerable<IFieldSymbol> fields)
    {
        return $@"
    protected override void InjectDependencies()
    {{{generateMethodBody(fields)}
    }}";
    }

    private static string generateMethodBody(IEnumerable<IFieldSymbol> fields)
    {
        return string.Concat(fields.Select(f => generateLine(f.Name, $"{f.Type}")));
    }

    private static string generateLine(string field, string type)
    {
        return $@"
        if (Owner.TryGetSingleComponent<{type}>(out var {field}))
        {{
            this.{field} = {field};
        }}
        else
        {{
            throw new InvalidOperationException(""Missing dependency for {field}"");
        }}";
    }
}
